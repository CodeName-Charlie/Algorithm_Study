// 문제
// 크기가 n인 삼각형 모양이 있다. 가장 위부터 선택하여 아래층으로 내려올 때,
// 이제까지 선택된 수의 합이 최대가 되는 경로를 구해보자.
// 이때, 현재 층에서는 대각선 왼쪽, 오른쪽만 선택할 수 있다.

// 문제 조건
// 삼각형의 크기 n은 1 이상 500 이하다.
// 현재 층에서는 대각선 왼쪽, 오른쪽만 선택 가능하다.
// 삼각형을 이루고 있는 각 수는 모두 정수이고, 0 이상 9999 이하다.

// 문제 해결 방법
// 동적 계획법을 이용하여 한층을 내려갔을 때 그 층까지의 누적합 중 최대값이 되는 값을 저장한다.
// 누적합 중 최대값이 되는 값을 저장하여 다시 처음부터 구하지 않도록 한다.

// 1. 삼각형의 크기 n을 입력 받는다.
// 2. 삼각형의 크기가 n일 때, 1층부터 n층에는 1,2,3,4,5...n 갯수의 숫자가 들어있다.
// 이는 1부터 n까지의 합 이므로, 1부터 n까지의 합을 구하는 공식인 n*n(+1)/2를 size에 저장한다.
// 2-1. 입력받을 값을 저장할 2차원 배열을 arr을 만들고, 누적합 중 최대값을 저장할 배열 dp를 만든다.
// 2-2. arr배열에 값을 입력 받는다.
// 2-3. dp배열의 0,1,2번째의 값은 고정이므로 미리 저장해둔다.

// 3. n층의 가장 첫번째 누적합은 n-1층 첫번째의 누적합(dp) + n 층의 첫번째 값(arr) 이고,
// n층의 가장 마지막 누적합은 n-1층 마지막의 누적합(dp) + n 층의 마지막 값이(arr) 된다.

// 3-1. n층의 2번째 값은 n-1층의 첫번째 누적합(dp)와 n-1의 두번째 누적합(dp)중 큰 값과
// n층의 2번째 값을 더한 값이 된다. 

// 4. 최대값을 찾아 출력해보자.

package Baekjun;

import java.util.Scanner;

public class P1932 {
	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);

		// 1. 삼각형의 크기 n을 입력 받는다.
		int n = sc.nextInt();

		// 2. n층까지 숫자의 갯수는 n*(n+1)/2이고, 이 값을 size에 저장하자.
		int size = n * (n + 1) / 2;

		// 2-1. n*n 크기의 배열을 만들자.
		int[][] arr = new int[n][n];

		// 최댓값을 저장하기 위한 변수를 만든다.
		int max = 0;

		// 누적합을 저장할 배열을 size 크기로 만든다.
		int[] dp = new int[size];

		// 2-2. arr배열에 값을 입력 받고,
		// 누적합의 0,1,2번째는 고정이므로 값을 저장해두자.
		for (int i = 0; i < n; i++) {
			for (int j = 0; j <= i; j++) {
				arr[i][j] = sc.nextInt();
				switch (i + j) {
				case 0:
					dp[0] = arr[0][0];
					max = dp[0];
					break;
				case 1:
					dp[1] = arr[0][0] + arr[1][0];
					max = Math.max(max, dp[1]);
					break;
				case 2:
					dp[2] = arr[0][0] + arr[1][1];
					max = Math.max(max, dp[2]);
					break;
				}
			}
		}

		// 누적합의 0,1,2번째는 고정이므로, 누적합 배열은 3부터 구하면 된다.
		int idx = 3;

		// arr은 2차원 배열이므로 2중 for문을 사용하자.
		// dp의 0,1,2번째 값은 저장되어 있는데, 이는 0행과 1행 값이므로
		// arr배열은 2행부터 시작하면 된다.
		for (int i = 2; i < n; i++) {
			// 2행 0~i열 부터 n-1행 0~i열 까지 반복해보자.
			for (int j = 0; j <= i; j++) {

				// n행 0열인 경우에는 n-1행 0열에 저장된 누적합과 n행 0열에 저장된 값을 더한다.
				if (j == 0) {
					dp[idx] = dp[idx - i] + arr[i][j];
				}
				// n행의 마지막 열인 경우에는 n-1행의 마지막 열에 저장된 누적합과 n행 마지막 열에 저장된 값을 더한다.
				else if (j == i) {
					dp[idx] = dp[idx - i - 1] + arr[i][j];
				}
				// 그 외의 경우에는 n층의 x번째 값은 n-1층의 x-1번째 누적합과 n-1의 x번째 누적합중 큰 값과
				// n층의 x번째 값을 더한다.
				else {
					dp[idx] = Math.max(dp[idx - i], dp[idx - i - 1]) + arr[i][j];

				}
				// 누적합을 저장하고 인덱스를 하나 늘리자.
				idx++;
			}
		}

		// 최댓값을 구하고 출력하자.
		for (int i = 0; i < size; i++) {
			max = Math.max(dp[i], max);
		}

		System.out.println(max);

	}
}
