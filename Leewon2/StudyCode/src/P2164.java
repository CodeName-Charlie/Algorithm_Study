import java.util.Scanner;

// 문제 조건
// 1<=N<=500,000

// 문제 해결 방법
// 규칙을 찾아 해결한다.
// 주요 규칙 : 연속되는 숫자를 쌍으로 생각하고, 앞에 있는 숫자는 삭제, 뒤에있는 숫자는 뒤로 이동시킨다.
// 예를들어, [1,2,3,4]의 경우, (1,2)를 한 쌍 (3,4)를 한 쌍으로 보고
// 앞에 있는 숫자인 1과 3은 삭제, 뒤에있는 숫자 2와 4는 뒤로 이동시킨다.
// 다음은 (2,4)가 한 쌍 만들어지고 2를 삭제 4를 뒤로 이동시킨다.
// 쌍이 만들어지지 않는다면 마지막에 있는 숫자를 출력한다.
// 세부 규칙 1 : 여기서는 앞에있는 숫자를 삭제할 필요 없이 뒤에있는 숫자만 배열의 뒤로 추가한다.
// 세부 규칙 2 배열의 크기 : 2개의 숫자 중 한개의 숫자가 뒤로 이동하는데, 숫자가 10개 있다면 총 5개의 숫자가 이동한다.
// 이를 식으로 표현하면, n/2 = 10/2 = 5 가 된다.
// 다시 5개의 숫자가 생기는데 2개의 숫자가 뒤로 이동하고 1개의 숫자가 남는다. 
// 2개의 숫자만 이동했으니 이를 식으로 표현하면, n//2 = 5//2 = 2가 된다.
// 이동하지 않은 숫자 + 이동한 숫자를 더하면 3이 되고, 이를 다시 뒤로 넘기면
// 1개의 숫자가 이동하고 2개의 숫자가 남는다.
// 마지막으로 2개의 숫자 중 한개의 숫자를 남기면 1개의 숫자가 이동하고 더이상 쌍을 이룰 수 없다.
// 이를 식으로 표현하면, n/2 + (n/2)*(1/2) + (n/2)*(1/2)*(1/2) + ..... 이 되고,
// 위 식을 간단히하면, n-1이 된다. 즉, 위 규칙을 따를 때 최종 배열의 크기는 n+n-1 = 2n-1로 생각하면 된다.

public class P2164 {
	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);

		// N을 입력 받는다.
		int N = sc.nextInt();

		// i가 홀수이면 arr[i]번째를 뒤에 추가한다.
		// 추가되는 수는 N-1개 이므로
		// 배열의 크기를 2*N -1 로 정한다.
		int[] arr = new int[2 * N - 1];

		// arr[i]에 1부터 N까지의 숫자를 넣는다.
		for (int i = 0; i < N; i++) {
			arr[i] = i + 1;
		}

		int k = 1;

		// i가 홀수라면,
		for (int i = 0; i < 2 * N - 1; i++) {
			if (i % 2 == 1) {
				// 배열의 뒷쪽에 추가한다.
				arr[i + N - k] = arr[i];
				k++;

			}
		}
		// 배열의 마지막에 있는 숫자를 출력하면 끝
		System.out.println(arr[2 * N - 2]);

	}
}
