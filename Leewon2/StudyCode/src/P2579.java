import java.util.Scanner;

// 문제
// 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점 까지 가야한다.
// 각각의 계단에는 일정한 점수가 쓰여있고, 계단을 밟으면 그 계단의 점수를 얻는다.
// 한번에 한 계단 혹은 두 계단씩 오를 수 있고, 연속된 세개의 계단을 모두 밟을수는 없다.
// 시작점은 계단에 포함되지 않고, 마지막 도착 계단은 반드시 밟아야 한다.
// 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구해보자.

// 문제 조건
// 시작점은 계단에 포함되지 않고, 마지막 도착 계단은 반드시 밟아야 한다.
// 연속된 세개의 계단을 밟을 수 없다.
// 계단의 개수는 300 이하의 자연수이고, 계단에 쓰여있는 점수는 10,000 이하의 자연수이다.

// 문제 해결 방법
// 1. n개의 숫자를 입력 받아 배열에 저장한다.
// 2. 점화식을 세워 최댓값을 출력해보자.
// 2-1. 계단의 마지막은 무조건 밟아야 하므로, 마지막을 기준으로 점화식을 세워보자.
// 2-2. 마지막 계단이 x라고 할 때, 마지막 계단은 무조건 밟으므로,
// x-1 혹은 x-2를 밟았다는 소리다. 연속된 3개의 계단은 밟을 수 없으므로, 
// x-1을 밟고 x에 도착했다면, x-2는 밟지 못하고 x-3은 조건에 상관 없이 선택할 수 있으므로 x-3에 저장된 최댓값을 더하면 된다.
// 반면, x-2를 밟고 왔다면, x-1은 밟지 못하고, x-3은 조건을 고려하고 선택해야 한다.

// 예를 들어, arr = [5,2,100,3,500]이 있다고 가정해보자.
// 마지막 도착 계단은 반드시 밟고, 연속된 세개의 계단은 밟을 수 없다는 조건으로 점수의 최댓값이 되는 새로운 배열 dp를 만든다.
// arr의 길이가 1인 경우, 즉, arr={5}인 경우, 마지막 수 5는 반드시 선택하고, 숫자가 3개 이하이므로 dp[0]=5가 된다. 이는 arr[0] = dp[0]으로 표현할 수 있다.

// arr = {5, 2}인 경우, 마지막 수 2는 반드시 선택하고, 숫자가 3개 이하이므로 arr[0]과 arr[1]을 모두 선택할 수 있다. 이는 arr[0] + arr[1] = dp[1]로 표현할 수 있다.

// arr = {5, 2, 100}인 경우, 마지막 수 100은 반드시 선택하고, 숫자가 3개 이상이므로 arr[0]과 arr[1]중 큰 값을 선택해야 한다.
// 이는 Math.max(arr[0],arr[1])+arr[2] = dp[2]로 표현할 수 있다.

// arr = {5, 2, 100, 3}인 경우, 마지막 수 3은 반드시 선택하고, 숫자가 3개 이상이므로 위의 조건에 맞게 비교해보자.
// arr[3]이전 값인 arr[2]를 선택한다면, arr[1]은 선택하지 못하고, arr[0]은 선택할 수 있다.
// arr[3]전전 값인 arr[1]을 선택한다면, arr[2]는 선택하지 못하고, arr[0]은 선택할 수 있다.
// 이는 Math.max(arr[2]+arr[0], arr[1]+arr[0])+arr[3]이 된다.
// arr[2]+arr[0]은 arr[2] + dp[0]으로, arr[1] + arr[0]은 dp[1]으로 바꾸어 쓸 수 있다.
// ★★★식을 정리해보면, dp[3] = Math.max(arr[2]+dp[0], dp[1]) + arr[3]이 된다.

// arr = {5, 2, 100, 3, 500}인 경우, 마지막 수 500은 반드시 선택하고, 숫자가 3개 이상이므로 조건에 맞게 비교해보자.
// 1. arr[4]이전 값인 arr[3]을 선택한다면, arr[2]는 선택하지 못하고, arr[1]은 선택할 수 있다. arr[3], arr[1]을 선택했으므로 arr[0]을 선택해도 상관이 없다.
// 2. arr[4]전전 값인 arr[2]를 선택한다면, arr[3]은 선택하지 못하고, arr[1]은 선택할 수 있다. 이때, arr[1]을 선택한다면, arr[2],arr[1]을 선택했으므로,
// arr[0]은 선택하지 못한다. 즉, arr[1]과 arr[0]중 큰 값을 선택해야 한다.

// 이를 식으로 표현해보면, 
// 1번은 dp[4] = arr[4] + arr[3] + arr[1] + arr[0]이 되고,
// 2번은 dp[4] = arr[4] + arr[2] + Math.max(arr[1],arr[0])이 된다.

// 여기서 알 수 있는 점은, 가장 마지막 수 -1 값을 선택했다면, 가장 마지막 수 -3은 조건을 고려하지 않고 선택할 수 있다.
// 즉, 가장 마지막 수 -3 까지 저장되어 있는 최댓값을 선택하면 된다.
// 이를 식으로 표현하면, dp[4] = arr[4] + arr[3] + dp[1]이 된다.

// 가장 마지막 수 -2 값을 선택했다면, 가장 마지막수 -3은 조건을 고려하고 선택해야 한다.
// 즉, dp[4] = arr[4] + arr[2] + Math.max(arr[1],arr[0])이 되는데,
// Math.max(arr[0],arr[1])+arr[2] = dp[2]이므로,
// dp[4] = arr[4] + dp[2]이 된다.

// 이를 ★★★와 같이 정리해보면, arr[4]는 공통적으로 더해지므로, dp[2]와 arr[3]+dp[1]중 큰 값을 선택하면 된다.
// dp[4] = Math.max(arr[3] + dp[1], dp[2]) + arr[4]가 된다.
// 위의 식과 ★★★의 식은 완전히 같으므로, n에 대한 식으로 바꾼다면
// dp[n] = Math.max(arr[n-1] + dp[n-3], dp[n-2]) + arr[n]이 된다.

public class P2579 {
	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);

		// n개의 숫자를 입력 받자.
		int n = sc.nextInt();

		// n크기의 배열을 만들자.
		int[] arr = new int[n];

		// 최댓값을 저장할 배열을 만들자.
		int[] dp = new int[n];

		// 반복문을 돌면서 arr배열에 값을 입력 받는다.
		for (int i = 0; i < n; i++) {
			arr[i] = sc.nextInt();

			// 스위치 케이스문을 이용해 dp[0], dp[1], dp[2]에 값을 저장한다.
			switch (i) {
			case 0:
				dp[0] = arr[0];
				break;
			case 1:
				dp[1] = Math.max(arr[1], arr[0] + arr[1]);
				break;
			case 2:
				dp[2] = Math.max(arr[1], arr[0]) + arr[2];
				break;
			}
		}

		// 반복문을 이용해 점화식으로 최댓값을 구하고 dp에 저장해보자.
		for (int i = 3; i < n; i++) {
			dp[i] = Math.max(dp[i - 3] + arr[i - 1], dp[i - 2]) + arr[i];
		}
		System.out.println(dp[n - 1]);

//		System.out.println(Arrays.toString(dp));
	}

}
