package Baekjoon;

import java.util.Scanner;

public class P2579 {
    // 계단 오르기
    // 시작점은 계단이 아니다.
    // 계단을 오를 때 하나 또는 두개를 오른다.
    // 3번 연속 계단 한 개를 오르면 안된다.
    // 마지막 계단은 무조건 올라야 한다.
    // 오른 계단 점수를 모두 더했을 때의 최대값을 구해서 출력한다.
    // 이 조건들을 따라서 계단을 오르는 식을 세운다.

    public static void main(String[] args) {

        // 스캐너 선언
        Scanner sc = new Scanner(System.in);

        // 계단의 갯수 입력받기
        // N번째 계단은 무조건 올라야 한다.
        int N = sc.nextInt();

        // 계단의 점수를 저장할 배열 생성
        // 시작점도 포함하므로 +1
        int[] step = new int[N+1];

        // 계단 점수 입력받기
        for (int i = 1; i < N + 1; i++) {
            step[i] = sc.nextInt();
        }

        // 메모이제이션을 사용하기 위해 배열 생성
        // 각 계단마다의 누적합의 최대값을 저장하는 배열이다.
        // 시작점도 포함하므로 +1
        int[] memo = new int[N+1];

        // 메모이제이션 배열을 초기화한다.
        // 0번 인덱스가 시작점이다.
        // 첫번째 계단은 자기 자신 1개밖에 없다.
        memo[1] = step[1];

        // N이 1일때를 위한 케이스를 따로 설정한다.
        // N이 1로 입력되면 2번 계단을 초기화 하면 안되므로
        // 2 이상의 값이 입력되면 2번 계단을 초기화 한다.
        if (N >= 2) {
            memo[2] = step[1] + step[2];
        }

        // 현재 계단(i)에서
        // 두 칸 전의 메모이제이션 배열에 저장된 값 : memo[i-2]
        // 한 칸 전(i-1)의 점수와 세 칸 전의 메모이제이션 배열에 저장된 값을 더한 값 : step[i-1]+memo[i-3]
        // 둘 중 큰 값을 현재 계단의 점수와 합해서 메모이제이션 배열에 저장한다.
        for(int i=3;i<N+1;i++){
            memo[i] = Math.max(memo[i-2],memo[i-3]+step[i-1])+step[i];
        }
        // 반복문이 끝나면 메모이제이션의 N번째 인덱스에는 최대값이 저장되어 있다.

        // 출력
        System.out.println(memo[N]);

    }
}
